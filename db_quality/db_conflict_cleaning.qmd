---
title: "db_conflict_cleaning"
format: html
editor: source
---

```{r}

# librarian downloads, if not already downloaded, and reads in needed packages
librarian::shelf(tidyverse, dbplyr, here, janitor, lubridate, RPostgres, stringr, DBI, parsedate, uuid, hms, RIBBiTR-BII/ribbitrrr)
# librarian::shelf(RIBBiTR-BII/ribbitrrr, update_all = TRUE)

# connect to database
dbcon = hopToDB()

```

Pull metadata and tables

```{r}
mdc = tbl(dbcon, Id("survey_data", "metadata_columns")) %>%
  collect()

# pull relevant chain tables from DB
db_aural = tbl(dbcon, Id("survey_data", "aural"))
db_capture = tbl(dbcon, Id("survey_data", "capture"))
db_ves = tbl(dbcon, Id("survey_data", "ves"))

db_survey = tbl(dbcon, Id("survey_data", "survey"))
db_visit = tbl(dbcon, Id("survey_data", "visit"))
db_site = tbl(dbcon, Id("survey_data", "site"))
db_region = tbl(dbcon, Id("survey_data", "region"))
db_country = tbl(dbcon, Id("survey_data", "country"))

db_cmr = tbl(dbcon, Id("survey_data", "cmr"))
db_bd = tbl(dbcon, Id("survey_data", "bd_qpcr_results"))

```

# NAs on natural key columns
```{r}

# join down
aural_chain = tbl_chain("aural", mdc)
capture_chain = tbl_chain("capture", mdc)
ves_chain = tbl_chain("ves", mdc)

db_aural_chain = tbl_join(dbcon, aural_chain, join = "full")
db_capture_chain = tbl_join(dbcon, capture_chain, join = "full")
db_ves_chain = tbl_join(dbcon, ves_chain, join = "full")

# na on visit.date

# identify conflict
db_conflict_aural = db_aural_chain %>%
  filter(is.null(date),
         is.na(survey_id),
         !is.na(visit_id)) %>%
  collect()

db_conflict_capture = db_capture_chain %>%
  filter(is.null(date),
         is.na(survey_id),
         !is.na(visit_id)) %>%
  collect()

db_conflict_ves = db_ves_chain %>%
  filter(is.null(date),
         is.na(survey_id),
         !is.na(visit_id)) %>%
  collect()

# nothing depends on these. just drop.

drop_visit = db_visit %>%
  filter(is.na(date)) %>%
  collect()

# rows_delete(db_visit, drop_visit, by="visit_id", unmatched="ignore")

## null detection type

# visit_ids in survey which are not found in visit
survey_invalid = db_survey %>%
  filter(is.na(detection_type))

aural_invalid = inner_join(db_aural, survey_invalid, by="survey_id") %>% collect()
capture_invalid = inner_join(db_capture, survey_invalid, by="survey_id") %>% collect()
ves_invalid = inner_join(db_ves, survey_invalid, by="survey_id") %>% collect()

# no observations which depend on survey_invalid. great. drop the nulls.
drop_survey = db_survey %>%
  filter(is.na(observers_survey) & is.na(duration_minutes) & is.na(detection_type))


dbBegin(dbcon)

tryCatch(
  {
    db_survey = db_survey %>%
      rows_delete(drop_survey, by="survey_id", unmatched = "ignore", in_place=TRUE)
    
    dbCommit(dbcon)
    print("Transaction successful! All tables are up to date.")
  }, error = function(e) {
    # Rollback in case of error
    dbRollback(dbcon)
    message("Transaction failed: ", e$message)
  })

# relable as detection type "other"

detection_type_rename = db_survey %>%
  filter(is.na(detection_type)) %>%
  mutate(detection_type = "other")

dbBegin(dbcon)

tryCatch(
  {
    db_survey = db_survey %>%
      rows_update(detection_type_rename, by="survey_id", unmatched = "ignore", in_place=TRUE)
    
    dbCommit(dbcon)
    print("Transaction successful!")
  }, error = function(e) {
    # Rollback in case of error
    dbRollback(dbcon)
    message("Transaction failed: ", e$message)
  })

```

orphaned data

```{r}

# visit_ids in survey which are not found in visit
survey_orphans = anti_join(db_survey, db_visit, by="visit_id")

aural_orphans = inner_join(db_aural, survey_orphans, by="survey_id") %>% collect()
capture_orphans = inner_join(db_capture, survey_orphans, by="survey_id") %>% collect()
ves_orphans = inner_join(db_ves, survey_orphans, by="survey_id") %>% collect()

# no orphans which depend on survey_orphans. great. drop them.

drop_survey = anti_join(db_survey, db_visit, by="visit_id") %>%
  select(any_of(colnames(db_survey)))

dbBegin(dbcon)

tryCatch(
  {
    db_survey = db_survey %>%
      rows_delete(drop_survey, by="survey_id", unmatched = "ignore", in_place=TRUE)
    
    dbCommit(dbcon)
    print("Transaction successful! All tables are up to date.")
  }, error = function(e) {
    # Rollback in case of error
    dbRollback(dbcon)
    message("Transaction failed: ", e$message)
  })

```

investigate duplicate bd_swab data...

```{r}

count_cap = db_capture %>% 
  filter(!is.na(bd_swab_id)) %>%
  summarize(count = n()) %>%
  pull(count)

count_pcr = db_bd %>% 
  filter(!is.na(bd_swab_id)) %>%
  summarize(count = n()) %>%
  pull(count)

unique_cap = db_capture %>% 
  filter(!is.na(bd_swab_id)) %>%
  select(bd_swab_id) %>%
  distinct() %>%
  summarize(count = n()) %>%
  pull(count)

unique_pcr = db_bd %>% 
  filter(!is.na(bd_swab_id)) %>%
  select(bd_swab_id) %>%
  distinct() %>%
  summarize(count = n()) %>%
  pull(count)

# investigate duplicates

dups_cap = db_capture %>%
  filter(!is.na(bd_swab_id)) %>%
  group_by(bd_swab_id) %>%
  mutate(n = n()) %>%
  filter(n>1) %>%
  ungroup() %>%
  collect()

dups_pcr = db_bd %>%
  filter(!is.na(bd_swab_id)) %>%
  group_by(bd_swab_id) %>%
  mutate(n = n()) %>%
  filter(n>1) %>%
  collect()

```

# drop duplicates acrosss all capture rows except capture_id
```{r}
duplicates_to_drop <- db_capture %>%
  group_by(across(-capture_id)) %>%
  mutate(row_number_in_group = row_number()) %>%
  ungroup() %>%
  filter(row_number_in_group > 1) %>%
  select(-row_number_in_group)

## drop
# db_capture = db_capture %>%
#   rows_delete(duplicates_to_drop, by="capture_id", unmatched = "ignore", in_place=TRUE)

```

# collect all bd_swab_ids and capture_ids
```{r}


peace = db_capture %>%
  left_join(db_survey, by = "survey_id") %>%
  left_join(db_visit, by = "visit_id") %>%
  left_join(db_site, by = "site_id") %>%
  left_join(db_region, by = "region_id") %>%
  group_by(survey_id,
           species_capture,
           time_of_capture,
           capture_trx_loc,
           body_temp_c,
           svl_mm,
           body_mass_g,
           microhabitat_type,
           site,
           date,
           region) %>%
  mutate(bd_id_count = n_distinct(bd_swab_id)) %>%
  filter(bd_id_count > 1,
         !is.na(time_of_capture)) %>%
  ungroup() %>%
  collect()

summarise(value = paste(unique(value), collapse = ", "), .groups = "drop")

train = db_capture %>%
  filter(survey_id == "01b5d9e9-ef7f-463d-b4a9-f8a1d64b9bbd") %>%
  collect()
```

Coalesce misnamed/duplicate columns
```{r}
# coalesce percent_cloud_cover
cc_survey = db_survey %>%
  mutate(
    cloud_cover_percent = as.numeric(cloud_cover_percent),
    cloud_cover_percent = coalesce(cloud_cover_percent, percent_cloud_cover))

# update
db_survey = db_survey %>%
  rows_update(cc_survey, by="survey_id", unmatched = "ignore", in_place=TRUE)

try = db_survey %>%
  filter(!is.na(cloud_cover_percent)) %>%
  collect()

this = db_survey %>%
  filter(!is.na(percent_cloud_cover)) %>%
  collect()

# relative_humidity_percent, relative_humidty_percent, relative_humidity_drop_percent

try = db_survey %>%
  filter(!is.na(relative_humidity_percent)) %>%
  collect()

that = db_survey %>%
  filter(!is.na(relative_humidty_percent)) %>%
  collect()

rh_survey = db_survey %>%
  mutate(
    relative_humidity_percent = coalesce(relative_humidity_percent, relative_humidty_percent))

now = rh_survey %>%
  filter(!is.na(relative_humidity_percent)) %>%
  collect()

# update
db_survey = db_survey %>%
  rows_update(rh_survey, by="survey_id", unmatched = "ignore", in_place=TRUE)

```

```{r}
# move survey environmental columns to their own table

calc_duration = function(start_time, end_time) {
  duration = if_else(end_time < start_time,
                         as_hms(86400) - start_time + end_time,
                         end_time - start_time)
  duration = duration / 60
  duration = str_remove(duration, " secs")
  duration = as.integer(round(as.numeric(duration), 0))
}

colnames(db_survey)

env_cols = c(
  "wind_speed_m_s",
  "air_temp_c",
  "water_temp_c",
  "p_h",
  "tds_ppm",
  "wind",
  "sky",
  "air_time",
  "water_time",
  "samp_loc",
  "pressure_psi",
  "dissolved_o2_percent",
  "salinity_ppt",
  "cloud_cover_percent",
  "precip",
  "soil_humidity_m3m3",
  "wind_speed_scale",
  "precipitation_during_visit",
  "precipitation_last_48_h",
  "temperature_last_48_h",
  "weather_condition_notes",
  "pressure_psi_drop",
  "relative_humidity_percent",
  "wind_speed_min_m_s",
  "wind_speed_max_m_s",
  "air_temp_c_drop",
  "densiometer_d1_num_covered",
  "d1_n",
  "d1_s",
  "d1_e",
  "d1_w",
  "d1_percent_cover",
  "densiometer_d2_num_covered",
  "d2_n",
  "d2_s",
  "d2_e",
  "d2_w",
  "d2_percent_cover",
  "depth_of_water_from_d2_cm",
  "vegetation_cover_percent",
  "vegetation_notes",
  "secchi_depth_cm",
  "conductivity_us_cm",
  "fish"
)

setdiff(colnames(db_survey), env_cols)

united_env = db_survey %>%
  select(-survey_id) %>%
  collect() %>%
  mutate(detection_type = "environmental") %>%
  group_by_at(env_cols) %>%
  mutate(start_time = as_hms(min(water_time, air_time)),
         end_time = as_hms(max(water_time, air_time)),
         duration_minutes = calc_duration(start_time, end_time),
         observers_survey = str_flatten_comma(unique(na.omit(unlist(str_split(observers_survey, ",\\s*")))), na.rm = TRUE),
         number_of_observers = length(unique(na.omit(unlist(str_split(observers_survey, ",\\s*"))))),
         comments_survey = str_flatten_comma(unique(comments_survey), na.rm = TRUE)) %>%
  ungroup()

gelled_env = united_env %>%
  distinct() %>%
  filter(rowSums(is.na(select(., air_time, water_time, air_temp_c, water_temp_c))) < 4) %>%
  group_by(visit_id, air_time, water_time, air_temp_c, water_temp_c, sky, wind) %>%
  summarise(across(everything(), ~ first(na.omit(.)), .names = "{col}"), .groups = "drop") %>%
  ungroup() %>%
  mutate(survey_id = "",
         survey_id = map_chr(survey_id, ~UUIDgenerate()))

repeated_env = unique_env %>%
  select(-survey_id) %>%
  group_by(visit_id) %>%
  mutate(rcount = n()) %>%
  ungroup() %>%
  filter(rcount > 1) %>%
  arrange(visit_id)

subset_env_survey = gelled_env %>%
  select(-any_of(env_cols))

subset_env = gelled_env %>%
  select(survey_id, 
         any_of(env_cols))

compare_survey_env = compare_df_cols(db_survey %>% filter(FALSE) %>% collect(), subset_env_survey)

compare_env = compare_df_cols(db_survey %>% filter(FALSE) %>% collect(), subset_env)

# looks like there are indeed cases where a set of env. parameters were taken at the beginning of each survey. In which case we leave env parameters in survey table.
```

calculate survey.duration_minutes
```{r}
# flip start and end time when durration in greater than 18 hours

rectified = db_survey %>%
  mutate(dm = sql("
    ROUND(CASE 
      WHEN end_time::time < start_time::time 
      THEN EXTRACT(EPOCH FROM (('24:00:00'::interval + end_time::interval) - start_time::interval)) / 60
      ELSE EXTRACT(EPOCH FROM (end_time::interval - start_time::interval)) / 60
    END, 0)
  ")) %>%
  filter(dm > 18 * 60) %>%
  mutate(temp = start_time,
         start_time = end_time,
         end_time = temp) %>%
  select(-dm,
         -temp)

db_survey = db_survey %>%
  rows_update(rectified, by="survey_id", unmatched = "ignore", in_place=TRUE)

```

recalculate duration for all surveys
```{r}
dm_survey = db_survey %>%
  mutate(duration_minutes = sql("
    ROUND(CASE 
      WHEN end_time::time < start_time::time 
      THEN EXTRACT(EPOCH FROM (('24:00:00'::interval + end_time::interval) - start_time::interval)) / 60
      ELSE EXTRACT(EPOCH FROM (end_time::interval - start_time::interval)) / 60
    END, 0)
  "))

db_survey = db_survey %>%
  rows_update(dm_survey, by="survey_id", unmatched = "ignore", in_place=TRUE)

```

calculate visit.time_of_day from min(survey.start_time)
```{r}
#define time of day as: midpoint of earliest survey start and latest survey end falls:
#   between 5:00 am and 18:59 pm -- day
#   Otherwise -- night

# preview
db_survey %>%
  left_join(db_visit, by = "visit_id") %>%
  group_by(date) %>%
  mutate(vs = n()) %>%
  filter(vs == 1) %>%
  ungroup() %>%
  select(start_time, end_time, visit_id, time_of_day) %>%
  group_by(visit_id) %>%
  mutate(mst = min(start_time, na.rm=TRUE),
         met = max(end_time, na.rm=TRUE),
         dur = ifelse(met < mst, met - mst + hours(24), met - mst),
         mid_time = mst + dur/2,
         tod_calc = ifelse(mean(hour(mid_time), na.rm=TRUE) >= 5 & mean(hour(mid_time), na.rm=TRUE) <= 18, "day", "night")) %>%
  ungroup() %>%
  filter(tod_calc != time_of_day)


# revise
tod_visit = db_survey %>%
  left_join(db_visit, by = "visit_id") %>%
  group_by(date) %>%
  mutate(vs = n()) %>%
  filter(vs == 1) %>%
  ungroup() %>%
  group_by(visit_id) %>%
  mutate(mst = min(start_time, na.rm=TRUE),
         met = max(end_time, na.rm=TRUE),
         dur = ifelse(met < mst, met - mst + hours(24), met - mst),
         mid_time = mst + dur/2,
         time_of_day = ifelse(mean(hour(mid_time), na.rm=TRUE) >= 5 & mean(hour(mid_time), na.rm=TRUE) <= 18, "day", "night")) %>%
  ungroup() %>%
  select(-mst,
         -met,
         -dur,
         -mid_time,
         -vs) %>%
  select(all_of(colnames(db_visit)))
  
db_visit = db_visit %>%
  rows_update(tod_visit, by="visit_id", unmatched = "ignore", in_place=TRUE)


```

# CMR duplicates
```{r}

# backup old cmr table
# cmr_backup = db_cmr %>%
#   collect()
# 
# # write_csv(cmr_backup, here("staging", "cmr_table_2024-11-18.csv"))
# 
# capture_backup = db_capture %>%
#   collect()
# 
# #write_csv(capture_backup, here("staging", "capture_table_2024-11-18.csv"))


cmr_scrape = db_capture %>%
  filter(!is.na(cmr_id)) %>%
  left_join(db_survey, by = "survey_id") %>%
  left_join(db_visit, by = "visit_id") %>%
  left_join(db_site, by = "site_id") %>%
  left_join(db_region, by = "region_id") %>%
  left_join(db_country, by = "country_id") %>%
  left_join(db_cmr, by = "cmr_id") %>%
  select(capture_id,
         cmr_id,
         local_cmr_id,
         species_capture,
         site,
         site_id,
         date,
         region,
         country_name) %>%
  distinct() %>%
  collect()


# does not generate unique uuids, needs fixing.
cmr_clean = cmr_scrape %>%
  mutate(uuidf = map_chr(cmr_id, ~ ifelse(!UUIDvalidate(.x), UUIDgenerate(), .x)),
         local_cmr_id = ifelse(UUIDvalidate(cmr_id), local_cmr_id, cmr_id),
         temp_cmr_id = uuidf) %>%
  filter(!is.na(local_cmr_id)) %>%
  select(-uuidf,
         -cmr_id)

cmr_typed = cmr_clean %>%
  mutate(id_type = case_when(is.na(local_cmr_id) ~ NA,
                                   region == "pennsylvania" ~ "toe_clip",
                                   TRUE ~ "pit_tag"))

toe_distinct = cmr_typed %>%
  filter(id_type == "toe_clip") %>%
  arrange(date) %>%
  group_by(species_capture, site_id) %>%
  distinct(local_cmr_id, .keep_all = TRUE) %>%
  ungroup()

pit_distinct = cmr_typed %>%
  filter(id_type == "pit_tag") %>%
  arrange(date) %>%
  distinct(local_cmr_id, .keep_all = TRUE) %>%
  ungroup()

cmr_distinct = bind_rows(toe_distinct,
                         pit_distinct) %>%
  rename(date_tagged = date,
         site_id_tagged = site_id,
         species_cmr = species_capture,
         cmr_id = temp_cmr_id) %>%
  select(cmr_id,
         everything(),
         -country_name,
         -region,
         -site,
         -capture_id)

# re-id duplicates in capture table...
cmr_capture = cmr_clean %>%
  select(-temp_cmr_id) %>%
  left_join(toe_distinct %>%
              select(local_cmr_id,
                     species_capture,
                     site_id,
                     temp_cmr_id), by = c("local_cmr_id", "species_capture", "site_id")) %>%
  left_join(pit_distinct %>%
              select(local_cmr_id,
                     temp_cmr_id), by = c("local_cmr_id")) %>%
  mutate(new_cmr_id = coalesce(temp_cmr_id.x, temp_cmr_id.y)) %>%
  select(capture_id, new_cmr_id) %>%
  rename(cmr_id = new_cmr_id)

dbWriteTable(dbcon, "temp_cmr_capture", cmr_capture, temporary = TRUE, overwrite = TRUE)

update_capture = db_capture %>%
  select(-cmr_id) %>%
  mutate(capture_id_text = sql("capture_id::text")) %>%
  left_join(
    tbl(dbcon, "temp_cmr_capture"),
    by = c("capture_id_text" = "capture_id")
  ) %>%
  select(-capture_id_text)

dbBegin(dbcon)

tryCatch(
  {
    
    db_capture = db_capture %>%
      rows_update(update_capture, by="capture_id", unmatched = "ignore", in_place = TRUE)
    
    
    dbWriteTable(dbcon, Id("survey_data", "cmr"), cmr_distinct, overwrite = TRUE)
    

    # Commit the transaction if successful
    dbCommit(dbcon)
    print("Transaction successful!")
    
  }, error = function(e) {
    # Rollback in case of error
    dbRollback(dbcon)
    message("Transaction failed: ", e$message)
  })





```


